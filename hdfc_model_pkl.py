# -*- coding: utf-8 -*-
"""hdfc_model.pkl.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1npWXMj3BbVPHhoblL9ntl_ANQG4N9hzV

Importing libraries
"""

import pandas as pd
import numpy as np

# Visualization
import matplotlib.pyplot as plt
import seaborn as sns

# Preprocessing
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.preprocessing import LabelEncoder
from sklearn.impute import SimpleImputer

# Models
from sklearn.linear_model import LogisticRegression
from sklearn.ensemble import RandomForestClassifier
from sklearn.svm import SVC

# Pipeline
from sklearn.pipeline import Pipeline
from sklearn.compose import ColumnTransformer

# Tuning
from sklearn.model_selection import GridSearchCV

# Evaluation
from sklearn.metrics import accuracy_score, classification_report, confusion_matrix

import joblib

"""Load Dataset"""

df = pd.read_csv("/content/HDFC.csv")

print(df.head())

print(df.info())

print(df.describe())

"""Handle Missing values"""

print(df.isnull().sum())

"""fill numeric with median"""

numeric_cols = df.select_dtypes(include=['int64','float64']).columns
df[numeric_cols] = df[numeric_cols].fillna(df[numeric_cols].median())

"""Fill categorical with mode"""

categorical_cols = df.select_dtypes(include=['object']).columns
for col in categorical_cols:
    df[col].fillna(df[col].mode()[0], inplace=True)

"""Encode Categorical Variables"""

le = LabelEncoder()

for col in categorical_cols:
    df[col] = le.fit_transform(df[col])

"""Define Features & Target"""

X = df.drop("Close", axis=1)
y = df["Close"]

"""Train Test Split"""

X_train, X_test, y_train, y_test = train_test_split(
    X, y,
    test_size=0.2,
    random_state=42

)

"""Create ML Pipeline"""

from sklearn.ensemble import RandomForestRegressor

pipeline = Pipeline([
    ('scaler', StandardScaler()),
    ('regressor', RandomForestRegressor(random_state=42))
])

"""Hyperparameter Tuning"""

from sklearn.ensemble import RandomForestRegressor
from sklearn.pipeline import Pipeline
from sklearn.preprocessing import StandardScaler

# Redefining the pipeline here to ensure the latest version is used.
# Ideally, the cell defining the pipeline (bP9iTrjSFFN7) should be re-executed.
pipeline = Pipeline([
    ('scaler', StandardScaler()),
    ('regressor', RandomForestRegressor(random_state=42))
])

param_grid = {
    'regressor__n_estimators': [100, 200],
    'regressor__max_depth': [None, 10, 20],
    'regressor__min_samples_split': [2, 5]
}

grid = GridSearchCV(
    pipeline,
    param_grid,
    cv=5,
    scoring='neg_mean_squared_error', # Changed scoring to a regression metric
    n_jobs=-1
)

grid.fit(X_train, y_train)

print("Best Parameters:", grid.best_params_)

"""Model Evaluation"""

from sklearn.metrics import mean_squared_error, mean_absolute_error, r2_score
import numpy as np

best_model = grid.best_estimator_

y_pred = best_model.predict(X_test)

# Evaluate with regression metrics
mse = mean_squared_error(y_test, y_pred)
rmse = np.sqrt(mse)
mae = mean_absolute_error(y_test, y_pred)
r2 = r2_score(y_test, y_pred)

print(f"Mean Squared Error (MSE): {mse:.2f}")
print(f"Root Mean Squared Error (RMSE): {rmse:.2f}")
print(f"Mean Absolute Error (MAE): {mae:.2f}")
print(f"R-squared (R2 Score): {r2:.2f}")

# For visualizing predicted vs actual, a scatter plot is more appropriate for regression
plt.figure(figsize=(10, 6))
sns.scatterplot(x=y_test, y=y_pred)
plt.xlabel("Actual Close Price")
plt.ylabel("Predicted Close Price")
plt.title("Actual vs. Predicted Close Prices")
plt.plot([y_test.min(), y_test.max()], [y_test.min(), y_test.max()], 'r--') # Diagonal line
plt.show()

"""Save Model"""

joblib.dump(best_model, "hdfc_model.pkl")

"""Alternative Models

Logistic Regression
"""

from sklearn.linear_model import LinearRegression

log_model = LinearRegression()
log_model.fit(X_train, y_train)

"""SVM"""

from sklearn.svm import SVR

svm_model = SVR(kernel='rbf', C=1, gamma='scale')
svm_model.fit(X_train, y_train)

"""Load Saved Mode"""

import joblib
import pandas as pd
import numpy as np

# Load trained model
model = joblib.load("hdfc_model.pkl")

"""Predict for Single New Data"""

new_data = np.array([[0, 334.00, 334.90, 331.50, 306.13, 2246218.0]]) # This is just an example. Replace with actual new data.

prediction = model.predict(new_data)

print("Prediction:", prediction[0])

"""Predict with Column Names"""

new_data = pd.DataFrame({
    'Date': [0],
    'Open': [334.00],
    'High': [334.90],
    'Low': [331.50],
    'Adj Close': [306.13],
    'Volume': [2246218.0]
})

prediction = model.predict(new_data)

print("Prediction:", prediction[0])

"""Predict Multiple Rows"""

new_data = pd.DataFrame({
    'Date': [0, 1],
    'Open': [334.00, 332.50],
    'High': [334.90, 337.37],
    'Low': [331.50, 326.77],
    'Adj Close': [306.13, 302.38],
    'Volume': [2246218.0, 3614496.0]
})

predictions = model.predict(new_data)

print("Predictions:", predictions)

"""Predict on Entire Dataset"""

predictions = model.predict(X)

df["Predicted"] = predictions

print(df.head())

"""Convert Prediction to Meaningful Output"""

if prediction[0] == 1:
    print("Loan Approved")
else:
    print("Loan Rejected")

"""# Easy Deployment Using Streamlit

app.py
"""

!pip install streamlit

import streamlit as st
import pandas as pd
import joblib

# Load trained pipeline model
model = joblib.load("hdfc_model.pkl")

st.set_page_config(page_title="HDFC Loan Prediction", layout="centered")

st.title("üè¶ HDFC Loan Prediction System")
st.markdown("Enter customer details to check loan approval status.")

# ----------- USER INPUT -------------
age = st.number_input("Age", min_value=18, max_value=100)
income = st.number_input("Income", min_value=0)
dependents = st.number_input("Number of Dependents", min_value=0)
loan_amount = st.number_input("Loan Amount", min_value=0)
credit_score = st.number_input("Credit Score", min_value=300, max_value=900)

# ----------- PREDICTION BUTTON ----------
if st.button("Predict Loan Status"):

    input_data = pd.DataFrame({
        "Age": [age],
        "Income": [income],
        "Dependents": [dependents],
        "LoanAmount": [loan_amount],
        "CreditScore": [credit_score]
    })

    prediction = model.predict(input_data)
    probability = model.predict_proba(input_data)

    if prediction[0] == 1:
        st.success(f"‚úÖ Loan Approved (Confidence: {probability[0][1]*100:.2f}%)")
    else:
        st.error(f"‚ùå Loan Rejected (Confidence: {probability[0][0]*100:.2f}%)")